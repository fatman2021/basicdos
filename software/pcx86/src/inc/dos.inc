;
; BASIC-DOS Operating System Definitions
;
; @author Jeff Parsons <Jeff@pcjs.org>
; @copyright Â© 2012-2020 Jeff Parsons
; @license MIT <https://www.pcjs.org/LICENSE.txt>
;
; This file is part of PCjs, a computer emulation software project at pcjs.org
;

	include	dev.inc
	include	dosapi.inc

IFNDEF DEBUG
REG_CHECK	equ	0	; no REG_FRAME marker on stack
ELSE
REG_CHECK	equ	2	; add a DEBUG marker before REG_FRAME
ENDIF

WS_TEMP		struc		; REG_WS workspace used for CTRLC dispatcing
JMP_IP		dw	?	; 00h
JMP_CS		dw	?	; 02h
RET_IP		dw	?	; 04h
RET_CS		dw	?	; 06h
RET_FL		dw	?	; 08h
WS_TEMP		ends

REG_FRAME	struc		; register frame created by dos_func
REG_BP		dw	?	; 00h
REG_DI		dw	?	; 02h (in case anyone wants to use LES DI)
REG_ES		dw	?	; 04h
REG_SI		dw	?	; 06h (in case anyone wants to use LDS SI)
REG_DS		dw	?	; 08h
REG_DX		dw	?	; 0Ah
REG_CX		dw	?	; 0Ch
REG_BX		dw	?	; 0Eh
REG_AX		dw	?	; 10h
REG_WS		dw (size WS_TEMP) SHR 1 dup (?)
REG_IP		dw	?	; 1Ch
REG_CS		dw	?	; 1Eh
REG_FL		dw	?	; 20h
REG_FRAME	ends

REG_AL		equ 	REG_AX.LOB
REG_AH		equ 	REG_AX.HIB
REG_BL		equ 	REG_BX.LOB
REG_BH		equ 	REG_BX.HIB
REG_CL		equ 	REG_CX.LOB
REG_CH		equ 	REG_CX.HIB
REG_DL		equ 	REG_DX.LOB
REG_DH		equ 	REG_DX.HIB

;
; Temp register definitions: an alternate use of the REG_WS workspace
;
TMP_AX		equ	REG_WS.JMP_IP
TMP_BX		equ	REG_WS.JMP_CS
TMP_CX		equ	REG_WS.RET_IP
TMP_DX		equ	REG_WS.RET_CS
TMP_ES		equ	REG_WS.RET_FL

TMP_AL		equ	TMP_AX.LOB
TMP_AH		equ	TMP_AX.HIB
TMP_BL		equ	TMP_BX.LOB
TMP_BH		equ	TMP_BX.HIB
TMP_CL		equ	TMP_CX.LOB
TMP_CH		equ	TMP_CX.HIB
TMP_DL		equ	TMP_DX.LOB
TMP_DH		equ	TMP_DX.HIB

;
; Session Control Block (SCB)
;
; SIDEBAR: To miminize the amount of per-process information in the IVT,
; we'll pretend all the apps we care about are well-behaved, which means if
; they want to set any of the EXRET/CTRLC/ERROR handlers, they'll use the
; DOS_SET_VECTOR function, which will update the SCB vectors below, rather
; than the actual IVT vectors.
;
; That will save scb_switch from having to save/restore IVT vectors on every
; switch.  If it turns out I care about running non-well-behaved apps later,
; then I'll add some vector-checking logic at appropriate checkpoints (or,
; worst case, copy selected vectors in/out on session switches -- yuck).
;
SCB		struc
SCB_STATUS	db	?	; 00h: SCB status
SCB_NUM		db	?	; 01h: SCB #
SCB_SFHCON	db	?	; 02h: SFH for CON
SCB_SFHAUX	db	?	; 03h: SFH for AUX
SCB_SFHPRN	db	?	; 04h: SFH for PRN
SCB_RESERVED	db	?	; 05h (holds SCBSIG in DEBUG builds)
SCB_CURPSP	dw	?	; 06h: current PSP
SCB_WAITID	dd	?	; 08h: wait ID if waiting, 0 if runnable
SCB_STACK	dd	?	; 0Ch: pointer to session stack
SCB_EXRET	dd	?	; 10h: current EXRET handler
SCB_CTRLC	dd	?	; 14h: current CTRLC handler
SCB_ERROR	dd	?	; 18h: current ERROR handler
SCB_DTA		dd	?	; 1Ch: current DTA (Disk Transfer Address)
SCB_CONTEXT	dw	?	; 20h: CONSOLE context (from device driver)
SCB_CURDRV	db	?	; 22h: current drive #
SCB_CTRLC_ALL	db	?	; 23h: 1 if CTRLC checking enabled on all calls
SCB_CTRLC_ACT	db	?	; 24h: 1 if CTRLC active
SCB_CTRLP_ACT	db	?	; 25h: 1 if CTRLP active
SCB_SWITCHAR	db	?	; 26h: current "switchar" (default is CHR_SLASH)
SCB_PADDING	db	?
SCB		ends

SCBSIG		equ	'S'

SCSTAT_INIT	equ	01h	; set if SCB initialized
SCSTAT_LOAD	equ	02h	; set if session has loaded a program
SCSTAT_START	equ	04h	; set if session program can be started

LOCK_SCB macro
	inc	[scb_locked]
	endm

UNLOCK_SCB macro
	jmp	scb_delock
	endm
;
; Memory Control Block (MCB)
;
MCB		struc
MCB_SIG		db	?	; 00h: either MCBSIG_NEXT or MCBSIG_LAST
MCB_OWNER	dw	?	; 01h: owner (PSP segment if > 8)
MCB_PARAS	dw	?	; 03h: size of block in paragraphs
MCB_RESERVED	db     11 dup(?); 05h: reserved
MCB		ends

MCBSIG_NEXT	equ	4Dh	; "M"
MCBSIG_LAST	equ	5Ah	; "Z"
MCBOWNER_NONE	equ	0	; free memory block
MCBOWNER_SYSTEM	equ	0008h	; owned by the system

;
; File Control Block (FCB)
;
FCB		struc
FCB_DRV		db	?	; 00h
FCB_NAME	db     11 dup(?); 01h
FCB_CURBLK	dw	?	; 0Ch
FCB_RECSIZE	dw	?	; 0Eh
FCB_FILESIZE	dd	?	; 10h
FCB_DATE	dw	?	; 14h
FCB_TIME	dw	?	; 16h
FCB		ends

;
; System File Block (SFB)
;
; For files, this is a superset of the directory entry (DIRENT).
;
; System File Handles (SFH) are indexes into the SFB table, whereas Process
; File Handles (PFH) are indexes into a PSP's Process File Table (PFT).
;
SFB		struc
SFB_NAME	db    11 dup (?); 00h: filename (E5=free,00=end)
SFB_ATTR	db	?	; 0Bh: attribute bits (see below)
SFB_DEVICE	dd	?	; 0Ch: device driver
SFB_CONTEXT	dw	?	; 10h: device context (1st cluster if file)
SFB_DRIVE	db	?	; 12h: drive # (-1 if not block device)
SFB_MODE	db	?	; 13h: open mode
SFB_HANDLES	db	?	; 14h: number of process handles
SFB_RESERVED	db	?	; 15h (holds SFBSIG in DEBUG builds)
SFB_TIME	dw	?	; 16h: time of last write (see below)
SFB_DATE	dw	?	; 18h: date of last write (see below)
SFB_CLN		dw	?	; 1Ah: 1st cluster number of file
SFB_SIZE	dd	?	; 1Ch: file size
SFB_CURPOS	dd	?	; 20h: current file position
SFB_CURCLN	dw	?	; 24h: current cluster number
SFB		ends
SFBSIG		equ	'F'

SFH_NONE	equ	0FFh	; if this SFH is in a PFT entry, it's unused

;
; The CONIO functions need a way of telling dev_request whether or not
; STDIN I/O requests should also perform CTRLC checks; set IO_RAW if not.
;
IO_RAW		equ	0
IO_COOKED	equ	1
IO_DIRECT	equ	-1

;
; EXE File Header
;
EXEHDR		struc
EXE_SIG		dw	?	; 00h: EXESIG
EXE_NBLAST	dw	?	; 02h: # bytes in last block (0 if full)
EXE_NBLOCKS	dw	?	; 04h: # blocks of EXE file data
EXE_NRELOCS	dw	?	; 06h: # relocation entries
EXE_PARASHDR	dw	?	; 08h: # header paras (includes reloc entries)
EXE_PARASMIN	dw	?	; 0Ah: # paras minimum additional
EXE_PARASMAX	dw	?	; 0Ch: # paras maximum additional
EXE_STACK_SEG	dw	?	; 0Eh: initial SS value
EXE_STACK_OFF	dw	?	; 10h: initial SP value
EXE_CHECKSUM	dw	?	; 12h: checksum of all words in file
EXE_START_OFF	dw	?	; 14h: initial IP value
EXE_START_SEG	dw	?	; 16h: initial CS value
EXE_OFFRELOC	dw	?	; 18h: offset of first relocation entry
EXE_OVERLAY	dw	?	; 1Ah: 0 for main program
EXEHDR		ends

EXESIG		equ	5A4Dh	; "MZ"
